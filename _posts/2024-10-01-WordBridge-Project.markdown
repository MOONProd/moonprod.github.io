---
layout: post
title:  "온라인 양방향 통신 끝말잇기 게임"
date:   2024-10-01 17:44:07 +0900
categories: Project
---

안녕하세요 최근 *프로젝트를 진행*하게 된 문소연입니다.

프로젝트는 배포를 목적으로 여전히 진행 중에 있습니다.  
기본적인 기능들을 가지고 어느정도 일단락 정리되는 정도까지 진행 되었습니다. 따라서 그 과정 속에서 임팩트 있게 경험한 어려움부터 배우게 됐던 점들을 리스트로 정리해 둘 생각입니다.

이 후, 더 공부하기 위해 관련된 포스트를 진행하고자 합니다.

### 로그인 Protected 검사에 대한 진행상황

1. ProtectedRoute에 토큰 검사하는 로직을
2. RouteList에서 묶어야 할 페이지가 많아지니까
3. ProtectedLayout으로 한 번에 묶어버리려고
4. 검사 로직을 Layout으로 옮기고 ProtectedRoute에는 Outlet을 설정
5. But, 이렇게 할 경우, 로그인이 되었다는 유무를 RouteList에 보내줘야하는데
6. 그렇게 하려면 이 정보를 recoil로 상태관리 필요
7. 그래서 상태관리를 하려다보니, 그럴거면 뭐하러 Route랑 Layout을 나눠?
8. 그냥 전역으로 로그인 상태 관리하는 로직 하나 박아넣고
9. 마운트될 때, 그거부터 검사해! 그래서 AuthCheck 만들기를 제안받음
10. 근데 내가 원래 하려던게 ProtectedRoute를 그런 식으로 만들고 싶었던 거잖아


### `ProtectedRoute`의 역할과 상태 관리

1. **`ProtectedRoute`의 역할**: `ProtectedRoute`의 주요 역할은 인증된 사용자만 특정 경로에 접근할 수 있도록 보호하는 것입니다. 이 컴포넌트는 인증이 완료되기 전에는 자식 컴포넌트를 렌더링하지 않으며, 인증이 완료된 경우에만 자식 컴포넌트를 렌더링합니다.
2. **인증 성공 여부를 직접 전달하지 않는 이유**: 인증 로직은 `ProtectedRoute` 내부에서 처리되기 때문에, 자식 컴포넌트가 별도로 인증 성공 여부를 알 필요가 없습니다. 즉, `ProtectedRoute`가 자식 컴포넌트를 렌더링한다는 것 자체가 인증에 성공했다는 것을 의미합니다.
3. **인증 상태 관리의 효율성**: 인증 상태 (`user` 변수 등)를 `ProtectedRoute` 외부로 전달하는 대신, 컴포넌트 내부에서만 관리합니다. 이렇게 하면, 인증 상태가 컴포넌트 내부에서만 변경되고 외부로 노출되지 않기 때문에 보안 및 데이터 일관성 측면에서 유리합니다.
4. **React Router의 `Outlet` 사용**: `Outlet`은 자식 라우트를 렌더링하는 역할을 하며, 부모 라우트에서 이미 인증이 확인되었기 때문에 자식 라우트로 별도의 데이터를 전달할 필요가 없습니다. `ProtectedRoute` 자체가 인증을 담당하고, 성공 시 자식 라우트를 렌더링하는 형태로 구성되므로, 자식 컴포넌트에서는 추가적인 인증 정보가 필요하지 않습니다.

대부분의 이슈가 `<Outlet/>` `{children}` 이었다.


### 구글 맵 API 사용 시
후공에서 만들어진 방에서 줌 트래킹

우리가 사용하는 @vis.gl/react-google-maps 라이브러리에서는 여기에서 제공되는 요소에 제한이 조금 있습니다.

그래서 react-google-maps에서 제공되는 이벤트가 말을 안 들을 수 있어요.

예를 들어, onTileLoaded를 출발로 ref, onLoaded? 등등 (onLoad는 콜백함수 사용 엘리먼트로 쓸 수는 있는 것 같음)

그래서 라이브러리를 react-google-maps 로 바꾸려고 시도했어요. 그랬더니 기존 라이브러리에서 사용하고 있던 AdvancedMarker와 Pin에 대한 설정을 동일시하는데 많은 문제가 있었습니다.

그리고 얘는 무슨 코드가.. 구닥다리 같음.. 나만 그렇게 느끼는건지.. 뭐 어쨌든 핀도 커스텀 하려니까 막 핀 이미지 불러와서 크기 키우고 이러는게 참 맘에 안 들긴 했습니다. 결국 그 벽을 넘지 못하고 다시 기존 라이브러리로 돌아옴요. → 이 과정에서 갈아 엎기를 두번 정도..

그래서 다시 동적 zoom을 설정하려고 했는데 다시 무한반복.. useRef도 안 먹어… `ref={myRef}`는 당연히 안 먹고, `onLoad{()⇒map.ref 어쩌구}`를 해야만 했습니다.. 

그러다가 지피티가 '혹시 너가 쓰는 라이브러리에 `useMap` 같은 훅을 사용할 수 있어?' 그러길래 docs를 찾아보니까 오 있길래 쓸 수 있길래 그렇다고 했더니 슥슥 `useMap`을 이용한 동적 줌을 제안해주더라고요.. 이 코드가 드디어 되었습니다…


### 생각보다 많이 쓰이고 배운 점

navigate와 함께 데이터를 전달하며 넘어가는 그 페이지에서 { data } = useLocation(); 으로 해당 데이터를 받아서 사용할 수가 있다!

그 Waiting에서인가 connectedUsers랑 connectedChatUsers를 구분하여 전체 채팅과 인겡미내 유저들과 따로 관리 할 수 있도록 할 수 있었다.

### 러프하게 정리 완료 !

이 외에도 힘들었던 부분이나 알게된 점들은 자잘하게 많이 존재합니다. 현재는 러프하게 리스트업만 해두는 걸로 마무리하겠습니다.