---
layout: post
title:  "React는 비동기다?"
date:   2024-08-14 19:03:52 +0900
categories: React
---

안녕하세요 한창 *React* 공부를 하고 있는 문소연입니다.

*React*는 성능 최적화를 위해 여러 작업을 **비동기**로 처리합니다. 그래서 '무조건 비동기다!' 라고 말하긴 어렵지만 비동기적인 동작이 자주 발생한다고 할 수 있습니다.

React에서 **비동기**로 처리되는 작업들과 **동기적**으로 처리되는 작업들에 대해 먼저 알아보겠습니다.  
그 후, 실습 진행 시 비동기 처리로 인해 문제되었던 점과 해결방법까지 정리해보겠습니다.

---

### React의 비동기
앞서 말했듯 대부분의 작업이 **비동기**로 처리되어지고 있습니다. 그 중 가장 자주 쓰여지는 작업을 위주로 살펴보겠습니다.

1. **"State 업데이트"**
   

   *React*에서 `useState`의 `setState`를 사용하여 상태를 업데이트 하고자 할 때, 이 작업이 **비동기적**으로 처리되곤 합니다.

   그 이유는 **최적화**를 위해서 여러 상태들을 업데이트 한 경우를 한 번에 처리 할 수 있기에, 이 과정에서 비동기적인 업데이트가 이루어집니다.

2. **"렌더링 과정"**
   
   *React*에서는 **효율성**을 위해 변경된 부분만 재렌더링을 시행합니다. 이 때의 렌더링 과정을 **비동기적**으로 처리하여 UI의 성능을 최적화 합니다.

   따라서 재렌더링이 될 경우에도 비동기적인 작동이 이루어 질 수 있습니다.
  
<br/>

---
### React의 동기
하지만 모든 작업이 비동기로 처리되는 것은 아니고, 효율을 위함이므로 *React*의 **동기적**인 동작에 대해서도 살펴보겠습니다.

1. **"렌더링"**
   
   컴포넌트가 **처음 렌더링**될 때에는 **동기적**으로 진행됩니다. 처음 렌더 이후의 과정은 비동기로 처리되기 때문에 **'렌더링 과정'**은 비동기에 속한다고 볼 수 있습니다.

   React가 컴포넌트의 `JSX`를 해석하여 `DOM`에 반영하는 과정은 동기적이라고 합니다.

2. **"이벤트 핸들러"**
   
   사용자 이벤트에 대한 반응은 **동기적**으로 처리됩니다. 

   단, 여기서 주의해야할 점은 이벤트 핸들러 내부의 코드는 동기적으로 시행되지만 내부에서 *상태를 업데이트* 할 때의 상태 변경은 **비동기적**으로 처리됩니다.

   *React의 비동기*에서 **'State 업데이트'**에 해당하는 부분이기 때문이죠.

3. **"기본 JavaScript 코드"**
   
   React 컴포넌트 안에서 작성된 일반적인 `JavaScript` 코드(조건문, 반복문 등)는 **동기적**으로 실행됩니다.

<br/>  

---
### 실습 적용 (UP&DOWN GAME)
**동기**와 **비동기** 처리에 대해 가장 헷갈릴만한 요소를 뽑아보자면 `useEffect`입니다.

`useEffect`는 **비동기** 작업을 처리해주는 용도로 사용합니다. **내부**에서 호출하는 비동기 작업이 **비동기적**으로 처리되지만, `useEffect` 자체는 **동기적**이기 때문입니다.


직관적으로 이해하자면, **비동기**로 작업되어지는 코드를 `useEffect`를 이용해 **동기적**으로 처리할 수 있다는 것입니다.
코드를 완전히 동기적으로 받아오는 것은 아니지만, 동기적 코드처럼 쉽게 작성할 수 있게 **도와주는 역할**을 합니다.

\+ `useEffect`는 비동기 작업을 안전하게 처리하고, 그 결과를 컴포넌트의 상태로 반영하는 데 적합한 환경을 제공합니다.

'숫자 UP&DOWN 게임'을 간단히 구현하는 동안 **비동기**와 관련된 문제를 만났습니다.

```javascript
  function checkNum() {
        setIsStarted(true);
 
        if(user_num > com_num)//사용자 입력값이 높을 때
        {
            setCount(count+1);
            setResult(`${count}번째 시도 [${user_num}] 낮춰주세요!`);
        }
        else if(user_num < com_num)//사용자 입력값이 낮을 때
        {
            setCount(count+1);
            setResult(`${count}번째 시도 [${user_num}] 높여주세요!`);
        }
        else //정답
        {
            setCount(count+1);
            setResult(`${count}번째 시도 정답입니다~~!!~`);
        }
        setUser_num("");
        // setLists([...lists,result]);
    }
```

`com_num`을 기준값(난수로 설정)으로 하여 해당 숫자를 맞추는 게임입니다. `checkNum()`함수는 숫자를 입력하고 '결과확인' 버튼을 클릭했을 때, 사용자가 입력한 값과 기준값을 비교하여 그 결과를 알려주는 로직을 구현합니다.

여기서 `setList`를 통해 결과를 화면에 리스트 형식으로 표현하고자 했습니다. 단순히 생각했을 때, '입력값에 대한 결과를 알려준 후 그 결과들을 리스트에 저장하면 되겠구나!' 라는 생각에   
해당 예시 코드 맨 아래 주석처리된 부분과 같이 `setLists([...lists,result]);`를 작성하였습니다.

그랬더니 리스트 순서가 하나씩 밀려서 출력되기 시작했습니다 !  
첫번째 리스트는 "" 빈배열.  
두번째 리스트는 "[1번째 시도] 50보다 낮춰주세요!"와 같이  
리스트가 밀려서 출력되었습니다.

이에 대한 원인을 찾아보니 **"State 업데이트"**의 **비동기**처리 방식 때문이었습니다.

원인을 알았으니 해결을 해야겠습니다 !!

```javascript
    useEffect(() => {
        if (result) {
            setLists((prevLists) => [...prevLists, result]);
        }
    }, [result]);
```

저는 `useEffect`를 통해 이를 해결하였습니다. 이 외에도 **동기적**으로 처리될 수 있도록 코드를 구현하는 방법도 있지만, `useEffect`의 사용법도 더 몸에 익힐겸 사용해보았습니다.

숫자를 입력하였을 때 결과를 책정하고 그 결과를 담는 `state`인 `[result]` 배열에 변화가 있을 때마다, `setList`상태에 그 결과 값을 추가하도록 이펙트를 주었습니다.

그러자 본 목적대로 숫자를 입력하고 '결과확인'버튼을 클릭하였을 때 해당 결과값이 밀리지않고 그대로 **리스트에 반영**되는 것을 확인할 수 있었습니다.
<br/>  

---
### 맺음말
`result` 문자열을 저장하는 변수를 하나 만들어서 그 변수를 `checkNum()`함수 내에서 `setList`에 담아주어도 **동기적**으로 처리되어질 수 있습니다.

*React*에서는 항상 유의하고 있어야할 **비동기식 처리방식**이라 제대로 이해하면 좋을 듯합니다.